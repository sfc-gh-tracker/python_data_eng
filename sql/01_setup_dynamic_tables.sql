-- =============================================================================
-- DYNAMIC TABLES DEMO: End-to-End Data Engineering Pipeline
-- =============================================================================
-- This script sets up a medallion architecture using Snowflake Dynamic Tables
-- Bronze → Silver → Gold layers with automatic incremental refresh
-- =============================================================================

USE ROLE ACCOUNTADMIN;

-- ─────────────────────────────────────────────────────────────────────────────
-- 1. DATABASE & WAREHOUSE SETUP
-- ─────────────────────────────────────────────────────────────────────────────
CREATE DATABASE IF NOT EXISTS DATA_ENGINEERING_DEMO
    COMMENT = 'Demo database for dynamic tables and Python data engineering';

CREATE WAREHOUSE IF NOT EXISTS WH_DATA_ENG
    WAREHOUSE_SIZE = 'XSMALL'
    AUTO_SUSPEND = 60
    AUTO_RESUME = TRUE
    INITIALLY_SUSPENDED = TRUE
    COMMENT = 'Warehouse for data engineering pipelines';

USE DATABASE DATA_ENGINEERING_DEMO;
USE WAREHOUSE WH_DATA_ENG;

-- ─────────────────────────────────────────────────────────────────────────────
-- 2. SCHEMA STRUCTURE (Medallion Architecture)
-- ─────────────────────────────────────────────────────────────────────────────
CREATE SCHEMA IF NOT EXISTS BRONZE COMMENT = 'Raw data ingestion layer';
CREATE SCHEMA IF NOT EXISTS SILVER COMMENT = 'Cleaned and conformed data';
CREATE SCHEMA IF NOT EXISTS GOLD   COMMENT = 'Business-ready aggregations';
CREATE SCHEMA IF NOT EXISTS STAGING COMMENT = 'Landing zone for external data';

-- ─────────────────────────────────────────────────────────────────────────────
-- 3. BRONZE LAYER: Raw Data Landing Tables
-- ─────────────────────────────────────────────────────────────────────────────

-- Raw IoT sensor readings (simulating manufacturing equipment)
CREATE OR REPLACE TABLE BRONZE.RAW_SENSOR_READINGS (
    RECORD_ID           NUMBER AUTOINCREMENT,
    DEVICE_ID           STRING NOT NULL,
    SENSOR_TYPE         STRING,
    READING_VALUE       FLOAT,
    READING_UNIT        STRING,
    READING_TIMESTAMP   TIMESTAMP_NTZ,
    RAW_PAYLOAD         VARIANT,
    INGESTED_AT         TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    SOURCE_FILE         STRING,
    PRIMARY KEY (RECORD_ID)
);

-- Raw transaction events
CREATE OR REPLACE TABLE BRONZE.RAW_TRANSACTIONS (
    TRANSACTION_ID      STRING NOT NULL,
    CUSTOMER_ID         NUMBER,
    PRODUCT_SKU         STRING,
    QUANTITY            NUMBER,
    UNIT_PRICE          FLOAT,
    TRANSACTION_TYPE    STRING,
    TRANSACTION_TIME    TIMESTAMP_NTZ,
    RAW_DATA            VARIANT,
    INGESTED_AT         TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    PRIMARY KEY (TRANSACTION_ID)
);

-- Raw customer events (clickstream, activities)
CREATE OR REPLACE TABLE BRONZE.RAW_CUSTOMER_EVENTS (
    EVENT_ID            STRING NOT NULL,
    SESSION_ID          STRING,
    CUSTOMER_ID         NUMBER,
    EVENT_TYPE          STRING,
    EVENT_PROPERTIES    VARIANT,
    PAGE_URL            STRING,
    USER_AGENT          STRING,
    IP_ADDRESS          STRING,
    EVENT_TIMESTAMP     TIMESTAMP_NTZ,
    INGESTED_AT         TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
    PRIMARY KEY (EVENT_ID)
);

-- ─────────────────────────────────────────────────────────────────────────────
-- 4. SILVER LAYER: Dynamic Tables for Cleaning & Transformation
-- ─────────────────────────────────────────────────────────────────────────────

-- Dynamic Table: Cleaned sensor readings with anomaly detection
CREATE OR REPLACE DYNAMIC TABLE SILVER.SENSOR_READINGS_CLEANED
    TARGET_LAG = '1 minute'
    WAREHOUSE = WH_DATA_ENG
    AS
SELECT
    RECORD_ID,
    DEVICE_ID,
    UPPER(TRIM(SENSOR_TYPE)) AS SENSOR_TYPE,
    READING_VALUE,
    UPPER(TRIM(READING_UNIT)) AS READING_UNIT,
    READING_TIMESTAMP,
    INGESTED_AT,
    -- Data quality flags
    CASE 
        WHEN READING_VALUE IS NULL THEN TRUE
        WHEN SENSOR_TYPE = 'TEMPERATURE' AND (READING_VALUE < -50 OR READING_VALUE > 200) THEN TRUE
        WHEN SENSOR_TYPE = 'PRESSURE' AND (READING_VALUE < 0 OR READING_VALUE > 1000) THEN TRUE
        WHEN SENSOR_TYPE = 'HUMIDITY' AND (READING_VALUE < 0 OR READING_VALUE > 100) THEN TRUE
        ELSE FALSE
    END AS IS_ANOMALY,
    -- Derived fields
    DATE(READING_TIMESTAMP) AS READING_DATE,
    HOUR(READING_TIMESTAMP) AS READING_HOUR,
    DAYOFWEEK(READING_TIMESTAMP) AS DAY_OF_WEEK
FROM BRONZE.RAW_SENSOR_READINGS
WHERE READING_VALUE IS NOT NULL;

-- Dynamic Table: Enriched transactions with validation
CREATE OR REPLACE DYNAMIC TABLE SILVER.TRANSACTIONS_ENRICHED
    TARGET_LAG = '1 minute'
    WAREHOUSE = WH_DATA_ENG
    AS
SELECT
    TRANSACTION_ID,
    CUSTOMER_ID,
    UPPER(TRIM(PRODUCT_SKU)) AS PRODUCT_SKU,
    QUANTITY,
    UNIT_PRICE,
    QUANTITY * UNIT_PRICE AS LINE_TOTAL,
    UPPER(TRIM(TRANSACTION_TYPE)) AS TRANSACTION_TYPE,
    TRANSACTION_TIME,
    DATE(TRANSACTION_TIME) AS TRANSACTION_DATE,
    EXTRACT(HOUR FROM TRANSACTION_TIME) AS TRANSACTION_HOUR,
    DAYNAME(TRANSACTION_TIME) AS DAY_NAME,
    WEEKOFYEAR(TRANSACTION_TIME) AS WEEK_NUMBER,
    INGESTED_AT,
    -- Data quality
    CASE 
        WHEN QUANTITY <= 0 THEN 'INVALID_QUANTITY'
        WHEN UNIT_PRICE < 0 THEN 'INVALID_PRICE'
        WHEN CUSTOMER_ID IS NULL THEN 'MISSING_CUSTOMER'
        ELSE 'VALID'
    END AS VALIDATION_STATUS
FROM BRONZE.RAW_TRANSACTIONS
WHERE TRANSACTION_TYPE IN ('SALE', 'RETURN', 'EXCHANGE');

-- Dynamic Table: Sessionized customer events
CREATE OR REPLACE DYNAMIC TABLE SILVER.CUSTOMER_SESSIONS
    TARGET_LAG = '1 minute'
    WAREHOUSE = WH_DATA_ENG
    AS
WITH event_sequence AS (
    SELECT
        SESSION_ID,
        CUSTOMER_ID,
        EVENT_TYPE,
        EVENT_TIMESTAMP,
        PAGE_URL,
        EVENT_PROPERTIES,
        ROW_NUMBER() OVER (PARTITION BY SESSION_ID ORDER BY EVENT_TIMESTAMP) AS EVENT_ORDER,
        LEAD(EVENT_TIMESTAMP) OVER (PARTITION BY SESSION_ID ORDER BY EVENT_TIMESTAMP) AS NEXT_EVENT_TIME
    FROM BRONZE.RAW_CUSTOMER_EVENTS
    WHERE SESSION_ID IS NOT NULL
)
SELECT
    SESSION_ID,
    CUSTOMER_ID,
    MIN(EVENT_TIMESTAMP) AS SESSION_START,
    MAX(EVENT_TIMESTAMP) AS SESSION_END,
    DATEDIFF('second', MIN(EVENT_TIMESTAMP), MAX(EVENT_TIMESTAMP)) AS SESSION_DURATION_SEC,
    COUNT(*) AS EVENT_COUNT,
    COUNT(DISTINCT PAGE_URL) AS PAGES_VIEWED,
    COUNT(DISTINCT EVENT_TYPE) AS UNIQUE_EVENT_TYPES,
    MAX(CASE WHEN EVENT_TYPE = 'PURCHASE' THEN 1 ELSE 0 END) AS HAS_PURCHASE,
    MAX(CASE WHEN EVENT_TYPE = 'ADD_TO_CART' THEN 1 ELSE 0 END) AS HAS_ADD_TO_CART,
    ARRAY_AGG(DISTINCT EVENT_TYPE) WITHIN GROUP (ORDER BY EVENT_TYPE) AS EVENT_TYPES_ARRAY,
    DATE(MIN(EVENT_TIMESTAMP)) AS SESSION_DATE
FROM event_sequence
GROUP BY SESSION_ID, CUSTOMER_ID;

-- ─────────────────────────────────────────────────────────────────────────────
-- 5. GOLD LAYER: Business Aggregations (Dynamic Tables)
-- ─────────────────────────────────────────────────────────────────────────────

-- Dynamic Table: Device health metrics (hourly rollup)
CREATE OR REPLACE DYNAMIC TABLE GOLD.DEVICE_HEALTH_HOURLY
    TARGET_LAG = '5 minutes'
    WAREHOUSE = WH_DATA_ENG
    AS
SELECT
    DEVICE_ID,
    SENSOR_TYPE,
    READING_DATE,
    READING_HOUR,
    COUNT(*) AS READING_COUNT,
    AVG(READING_VALUE) AS AVG_VALUE,
    MIN(READING_VALUE) AS MIN_VALUE,
    MAX(READING_VALUE) AS MAX_VALUE,
    STDDEV(READING_VALUE) AS STDDEV_VALUE,
    SUM(CASE WHEN IS_ANOMALY THEN 1 ELSE 0 END) AS ANOMALY_COUNT,
    ROUND(SUM(CASE WHEN IS_ANOMALY THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) AS ANOMALY_RATE_PCT
FROM SILVER.SENSOR_READINGS_CLEANED
GROUP BY DEVICE_ID, SENSOR_TYPE, READING_DATE, READING_HOUR;

-- Dynamic Table: Daily sales summary
CREATE OR REPLACE DYNAMIC TABLE GOLD.DAILY_SALES_SUMMARY
    TARGET_LAG = '5 minutes'
    WAREHOUSE = WH_DATA_ENG
    AS
SELECT
    TRANSACTION_DATE,
    DAY_NAME,
    COUNT(DISTINCT TRANSACTION_ID) AS TOTAL_TRANSACTIONS,
    COUNT(DISTINCT CUSTOMER_ID) AS UNIQUE_CUSTOMERS,
    COUNT(DISTINCT PRODUCT_SKU) AS UNIQUE_PRODUCTS,
    SUM(CASE WHEN TRANSACTION_TYPE = 'SALE' THEN LINE_TOTAL ELSE 0 END) AS GROSS_SALES,
    SUM(CASE WHEN TRANSACTION_TYPE = 'RETURN' THEN LINE_TOTAL ELSE 0 END) AS RETURNS,
    SUM(CASE WHEN TRANSACTION_TYPE = 'SALE' THEN LINE_TOTAL ELSE -LINE_TOTAL END) AS NET_SALES,
    SUM(QUANTITY) AS TOTAL_UNITS,
    AVG(LINE_TOTAL) AS AVG_TRANSACTION_VALUE,
    SUM(CASE WHEN VALIDATION_STATUS != 'VALID' THEN 1 ELSE 0 END) AS INVALID_TRANSACTIONS
FROM SILVER.TRANSACTIONS_ENRICHED
GROUP BY TRANSACTION_DATE, DAY_NAME;

-- Dynamic Table: Customer behavior metrics
CREATE OR REPLACE DYNAMIC TABLE GOLD.CUSTOMER_BEHAVIOR_METRICS
    TARGET_LAG = '5 minutes'
    WAREHOUSE = WH_DATA_ENG
    AS
SELECT
    CUSTOMER_ID,
    COUNT(DISTINCT SESSION_ID) AS TOTAL_SESSIONS,
    AVG(SESSION_DURATION_SEC) AS AVG_SESSION_DURATION,
    SUM(EVENT_COUNT) AS TOTAL_EVENTS,
    AVG(PAGES_VIEWED) AS AVG_PAGES_PER_SESSION,
    SUM(HAS_PURCHASE) AS PURCHASE_SESSIONS,
    SUM(HAS_ADD_TO_CART) AS CART_SESSIONS,
    ROUND(SUM(HAS_PURCHASE) * 100.0 / NULLIF(COUNT(*), 0), 2) AS CONVERSION_RATE,
    MIN(SESSION_START) AS FIRST_SEEN,
    MAX(SESSION_END) AS LAST_SEEN,
    DATEDIFF('day', MIN(SESSION_DATE), MAX(SESSION_DATE)) AS ACTIVE_DAYS_SPAN
FROM SILVER.CUSTOMER_SESSIONS
WHERE CUSTOMER_ID IS NOT NULL
GROUP BY CUSTOMER_ID;

-- Dynamic Table: Product performance
CREATE OR REPLACE DYNAMIC TABLE GOLD.PRODUCT_PERFORMANCE
    TARGET_LAG = '5 minutes'
    WAREHOUSE = WH_DATA_ENG
    AS
SELECT
    PRODUCT_SKU,
    COUNT(DISTINCT TRANSACTION_ID) AS TRANSACTION_COUNT,
    COUNT(DISTINCT CUSTOMER_ID) AS UNIQUE_BUYERS,
    SUM(QUANTITY) AS TOTAL_UNITS_SOLD,
    SUM(LINE_TOTAL) AS TOTAL_REVENUE,
    AVG(UNIT_PRICE) AS AVG_SELLING_PRICE,
    MIN(TRANSACTION_DATE) AS FIRST_SALE_DATE,
    MAX(TRANSACTION_DATE) AS LAST_SALE_DATE,
    DATEDIFF('day', MIN(TRANSACTION_DATE), MAX(TRANSACTION_DATE)) AS DAYS_ON_MARKET,
    SUM(CASE WHEN TRANSACTION_TYPE = 'RETURN' THEN 1 ELSE 0 END) AS RETURN_COUNT,
    ROUND(SUM(CASE WHEN TRANSACTION_TYPE = 'RETURN' THEN 1 ELSE 0 END) * 100.0 / 
          NULLIF(COUNT(*), 0), 2) AS RETURN_RATE_PCT
FROM SILVER.TRANSACTIONS_ENRICHED
WHERE VALIDATION_STATUS = 'VALID'
GROUP BY PRODUCT_SKU;

-- ─────────────────────────────────────────────────────────────────────────────
-- 6. PIPELINE MONITORING VIEWS
-- ─────────────────────────────────────────────────────────────────────────────

CREATE OR REPLACE VIEW GOLD.V_DYNAMIC_TABLE_STATUS AS
SELECT
    NAME AS TABLE_NAME,
    SCHEMA_NAME,
    TARGET_LAG,
    REFRESH_MODE,
    SCHEDULING_STATE,
    LAST_COMPLETED_REFRESH,
    DATA_TIMESTAMP
FROM TABLE(INFORMATION_SCHEMA.DYNAMIC_TABLES())
WHERE DATABASE_NAME = 'DATA_ENGINEERING_DEMO'
ORDER BY SCHEMA_NAME, NAME;

CREATE OR REPLACE VIEW GOLD.V_PIPELINE_FRESHNESS AS
SELECT
    'BRONZE.RAW_SENSOR_READINGS' AS TABLE_NAME,
    MAX(INGESTED_AT) AS LATEST_DATA,
    COUNT(*) AS ROW_COUNT
FROM BRONZE.RAW_SENSOR_READINGS
UNION ALL
SELECT
    'BRONZE.RAW_TRANSACTIONS',
    MAX(INGESTED_AT),
    COUNT(*)
FROM BRONZE.RAW_TRANSACTIONS
UNION ALL
SELECT
    'BRONZE.RAW_CUSTOMER_EVENTS',
    MAX(INGESTED_AT),
    COUNT(*)
FROM BRONZE.RAW_CUSTOMER_EVENTS;

-- ─────────────────────────────────────────────────────────────────────────────
-- 7. SEED SAMPLE DATA FOR TESTING
-- ─────────────────────────────────────────────────────────────────────────────

-- Sensor data seed
INSERT INTO BRONZE.RAW_SENSOR_READINGS 
    (DEVICE_ID, SENSOR_TYPE, READING_VALUE, READING_UNIT, READING_TIMESTAMP, RAW_PAYLOAD)
SELECT
    'DEVICE_' || LPAD(UNIFORM(1, 50, RANDOM())::STRING, 3, '0') AS DEVICE_ID,
    (ARRAY_CONSTRUCT('TEMPERATURE', 'PRESSURE', 'HUMIDITY', 'VIBRATION'))[UNIFORM(0, 3, RANDOM())::INT]::STRING AS SENSOR_TYPE,
    CASE 
        WHEN UNIFORM(0, 3, RANDOM()) = 0 THEN UNIFORM(15, 85, RANDOM())::FLOAT  -- Temperature
        WHEN UNIFORM(0, 3, RANDOM()) = 1 THEN UNIFORM(100, 500, RANDOM())::FLOAT  -- Pressure
        WHEN UNIFORM(0, 3, RANDOM()) = 2 THEN UNIFORM(20, 80, RANDOM())::FLOAT  -- Humidity
        ELSE UNIFORM(0, 100, RANDOM())::FLOAT  -- Vibration
    END AS READING_VALUE,
    CASE 
        WHEN UNIFORM(0, 3, RANDOM()) = 0 THEN 'CELSIUS'
        WHEN UNIFORM(0, 3, RANDOM()) = 1 THEN 'PSI'
        WHEN UNIFORM(0, 3, RANDOM()) = 2 THEN 'PERCENT'
        ELSE 'MM/S'
    END AS READING_UNIT,
    DATEADD('minute', -1 * UNIFORM(0, 10080, RANDOM()), CURRENT_TIMESTAMP()) AS READING_TIMESTAMP,
    OBJECT_CONSTRUCT('raw', TRUE, 'version', '1.0') AS RAW_PAYLOAD
FROM TABLE(GENERATOR(ROWCOUNT => 5000));

-- Transaction data seed
INSERT INTO BRONZE.RAW_TRANSACTIONS 
    (TRANSACTION_ID, CUSTOMER_ID, PRODUCT_SKU, QUANTITY, UNIT_PRICE, TRANSACTION_TYPE, TRANSACTION_TIME, RAW_DATA)
SELECT
    'TXN_' || UUID_STRING() AS TRANSACTION_ID,
    UNIFORM(10001, 10500, RANDOM()) AS CUSTOMER_ID,
    'SKU_' || LPAD(UNIFORM(1, 200, RANDOM())::STRING, 4, '0') AS PRODUCT_SKU,
    UNIFORM(1, 10, RANDOM()) AS QUANTITY,
    ROUND(UNIFORM(10, 500, RANDOM()) + RANDOM() / 10000000000, 2) AS UNIT_PRICE,
    (ARRAY_CONSTRUCT('SALE', 'SALE', 'SALE', 'SALE', 'RETURN', 'EXCHANGE'))[UNIFORM(0, 5, RANDOM())::INT]::STRING AS TRANSACTION_TYPE,
    DATEADD('hour', -1 * UNIFORM(0, 720, RANDOM()), CURRENT_TIMESTAMP()) AS TRANSACTION_TIME,
    OBJECT_CONSTRUCT('source', 'POS', 'store_id', UNIFORM(1, 50, RANDOM())) AS RAW_DATA
FROM TABLE(GENERATOR(ROWCOUNT => 3000));

-- Customer events seed
INSERT INTO BRONZE.RAW_CUSTOMER_EVENTS 
    (EVENT_ID, SESSION_ID, CUSTOMER_ID, EVENT_TYPE, EVENT_PROPERTIES, PAGE_URL, USER_AGENT, IP_ADDRESS, EVENT_TIMESTAMP)
SELECT
    'EVT_' || UUID_STRING() AS EVENT_ID,
    'SESS_' || MD5(UNIFORM(1, 1000, RANDOM())::STRING) AS SESSION_ID,
    UNIFORM(10001, 10500, RANDOM()) AS CUSTOMER_ID,
    (ARRAY_CONSTRUCT('PAGE_VIEW', 'CLICK', 'ADD_TO_CART', 'REMOVE_FROM_CART', 'PURCHASE', 'SEARCH'))[UNIFORM(0, 5, RANDOM())::INT]::STRING AS EVENT_TYPE,
    OBJECT_CONSTRUCT('device', (ARRAY_CONSTRUCT('mobile', 'desktop', 'tablet'))[UNIFORM(0, 2, RANDOM())::INT]::STRING) AS EVENT_PROPERTIES,
    '/page/' || UNIFORM(1, 100, RANDOM()) AS PAGE_URL,
    'Mozilla/5.0' AS USER_AGENT,
    CONCAT(UNIFORM(1, 255, RANDOM()), '.', UNIFORM(1, 255, RANDOM()), '.', UNIFORM(1, 255, RANDOM()), '.', UNIFORM(1, 255, RANDOM())) AS IP_ADDRESS,
    DATEADD('minute', -1 * UNIFORM(0, 10080, RANDOM()), CURRENT_TIMESTAMP()) AS EVENT_TIMESTAMP
FROM TABLE(GENERATOR(ROWCOUNT => 10000));

-- ─────────────────────────────────────────────────────────────────────────────
-- 8. VERIFY SETUP
-- ─────────────────────────────────────────────────────────────────────────────
SELECT '✅ Setup Complete!' AS STATUS;
SELECT * FROM GOLD.V_DYNAMIC_TABLE_STATUS;
SELECT * FROM GOLD.V_PIPELINE_FRESHNESS;

